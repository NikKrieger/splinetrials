---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# splinetrials

<!-- badges: start -->
[![Codecov test coverage](https://codecov.io/gh/NikKrieger/splinetrials/graph/badge.svg)](https://app.codecov.io/gh/NikKrieger/splinetrials)
[![R-CMD-check](https://github.com/NikKrieger/splinetrials/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/NikKrieger/splinetrials/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

The goal of splinetrials is to analyze longitudinal clinical data applying natural cubic splines to a continuous time variable.

## Installation

You can install the development version of splinetrials from [GitHub](https://github.com/NikKrieger/splinetrials) with:

``` r
# install.packages("pak")
pak::pak("NikKrieger/splinetrials")
```
# Methods

The NCS model is a longitudinal mixed model of repeated measures (MMRM) with random effects marginalized out, additive baseline covariates, and time parameterized using natural cubic splines. The parameterization has additive effects and pairwise interactions for study arm and time point (i.e., spline basis functions). The model is constrained so that all study arms have equal means at baseline.

# Data

We begin with a clinical data set with one row per patient per scheduled visit (including baseline). The following simulated data set represents the general structure (e.g. column names) but not necessarily realistic responses.

```{r}
set.seed(1)
library(dplyr)
data <-
  mutate(
    cross_join(
      data.frame(
        patient = do.call(paste0, expand.grid(LETTERS, letters))[1:50],
        arm =
          sample(c("control", "active1", "active2"), 50, replace = TRUE),
        categorical1 = sample(paste0("level", 1:3), 50, replace = TRUE),
        categorical2 = sample(c("level1", "level2"), 50, replace = TRUE),
        continuous1 = rnorm(50),
        continuous2 = rnorm(50)
      ),
      data.frame(
        time_observed_index = seq_len(8),
        time_scheduled_index = seq_len(8),
        time_scheduled_label =
          c("Baseline", paste("visit", c(3, 4, 5, 7, 8, 9, 12))),
        time_scheduled_continuous = seq(from = 0, length.out = 8) / 4
      )
    ),
    time_observed_continuous =
      time_scheduled_continuous + runif(n(), min = -0.1, max = 0.1),
    response =
      rnorm(
        n(),
        10 - (1 * (arm == "active1") + 2 * (arm == "active2") +
                3 * (arm == "control")) * sqrt((time_observed_index / 4) -
                                                 min(time_observed_index / 4))
      )
  )

head(data)
```

The following is a summary of the required columns in the data set. Here are the columns not related to time points or visits:

1. `response`: User-supplied numeric vector of responses to the clinical endpoint. Could be `AVAL`.
2. `patient`: User-supplied character vector, ID of the patient in the study. Usually `USUBJID`.
3. `arm`: User-supplied character vector, study arm of the given patient.
4. `categorical1`, `categorical2`: User-supplied example categorical baseline covariates.
5. `continuous1`, `continuous2`: User-supplied example continuous baseline covariates.

Here are the columns related to time points or visits:

1. `time_observed_continuous`: User-supplied numeric vector of continuous times corresponding to each observed patient visit. Varies from patient to patient. Units could be in years, months, or days, or some other unit. Must be on the same time scale as `time_scheduled_continuous`. (If the former is in weeks, then the latter must also be in weeks.)
2. `time_observed_index`: User-supplied integer index vector of *bins* of observed time points. These numeric labels should indicate groupings of time points based on rounding `time_observed_continuous` to a small set of strategic fixed time points.
3. `time_observed_factor`: Derived ordered factor version of `time_observed_index` to structure the correlation matrix. Derived as `ordered(as.character(time_observed_index), levels = as.character(sort(unique(time_observed_index))))`.
4. `time_scheduled_index`: User-supplied integer index vector of scheduled visit numbers. Usually `AVISITN`.
5. `time_scheduled_label`: User-supplied character vector of human-readable scheduled visit labels. Usually `AVISIT`.
6. `time_scheduled_continuous`: User-supplied numeric vector of continuous times of when each visit was scheduled. It must be on the same time scale as `time_scheduled_continuous`, the values must have a one-to-one correspondence with the scheduled visits in `time_scheduled_label`, and the baseline must have a value of 0. If the time scale is weeks, then the study team can create this variable in advance using `time_scheduled_label` (e.g. `AVISIT`). For example, if `AVISIT` is `"Baseline"`, then `time_scheduled_continuous` must be 0. If `time_scheduled_label` is `"Visit Number 5 (Week 24)"`, then `time_scheduled_continuous` should be 24.

## Main analysis

The NCS analysis is a call to a single function: `ncs_analysis()`. This produces a table of summary statistics, including LS means and confidence intervals. All arguments to `ncs_analysis()` should be exposed as user inputs.

```{r, message = FALSE}
library(splinetrials)
results_table <- ncs_analysis(
  data = data,
  response = "response",
  subject = "patient",
  arm = "arm",
  control_group = "control",
  time_observed_continuous = "time_observed_continuous",
  time_observed_index = "time_observed_index",
  time_scheduled_continuous = "time_scheduled_continuous",
  time_scheduled_label = "time_scheduled_label",
  covariates = ~ continuous1 + categorical2,
  cov_structs = c("us", "toeph", "ar1h", "csh", "cs"),
  df = 3
)
```

```{r}
results_table
```

The table has one row per study arm per timepoint of interest and the following columns.

* `arm`: study arm, i.e. treatment group
* `time`: discrete visit time labels from the `time_scheduled_label` column in the data.
* `n`: number of non-missing observations.
* `est`: observed mean response in the data.
* `sd`: observed standard deviation of the response in the data.
* `se`: observed standard error of the response in the data (just `se / sqrt(n)`).
* `lower`: lower bound of an observed 95% confidence interval in the data.
* `upper`: upper bound of an observed 95% confidence interval in the data.
* `response_est`: LS mean of the response.
* `response_se`: standard error of the LS mean of the response.
* `response_df`: degrees of freedom of the LS mean of the response.
* `response_lower`: lower 95% confidence bound of the LS mean of the response.
* `response_upper`: upper 95% confidence bound of the LS mean of the response.
* `change_est`, `change_lower`, `change_upper`, `change_se`, `change_df`: like the analogous `response_*` columns, but for LS mean change from baseline.
* `change_test_statistic`: test statistic of a two-sided test that the LS mean change from baseline is not equal to 0, at a significance level of 5%.
* `change_p_value`: same as `change_test_statistic`, but the p-value instead of the test statistic.
* `diff_est`, `diff_se`, `diff_df`, `diff_lower`, `diff_upper`, `diff_test_statistic`, `diff_p_value`: same as the analogous `change_*` columns, but for treatment differences.
* `percent_slowing_est` LS mean of percent slowing (on the percentage scale).
* `percent_slowing_lower`, `percent_slowing_upper`: a conservative approximation to a confidence interval on percent slowing. Assumes uncorrelated changes from baseline.
* `correlation`: correlation structure of the whole model.
* `optimizer`: optimization algorithm for the whole model.

We can plot the model against the data.

```{r plot_means_no_subgroup}
ncs_plot_means(results_table)
```

## Subgroup analysis

The subgroup analysis is similar, but it begins with a data set with a categorical variable column to indicate subgroup membership.

```{r}
set.seed(1)
data_with_subgroup <-
  mutate(
    cross_join(
      data.frame(
        patient = do.call(paste0, expand.grid(LETTERS, letters))[1:120],
        arm = rep(c("control", "active1", "active2"), each = 40),
        subgroup = rep(c("subgroup1", "subgroup2", "subgroup3"), times = 40),
        categorical1 = sample(paste0("level", 1:3), 120, replace = TRUE),
        categorical2 = sample(c("level1", "level2"), 120, replace = TRUE),
        continuous1 = rnorm(120),
        continuous2 = rnorm(120)
      ),
      data.frame(
        time_observed_index = seq_len(8),
        time_scheduled_index = seq_len(8),
        time_scheduled_label =
          c("Baseline", paste("visit", c(3, 4, 5, 7, 8, 9, 12))),
        time_scheduled_continuous = as.numeric(seq(from = 0, length.out = 8) / 4)
      )
    ),
    time_observed_continuous =
      time_scheduled_continuous + runif(n(), min = -0.1, max = 0.1),
    response = rnorm(
      n(),
      mean =
        10 - (1 * (arm == "active1") + 2 * (arm == "active2") +
                3 * (arm == "control")) * sqrt((time_observed_index / 4) -
                                                 min(time_observed_index / 4))
    )
  )
```

```{r}
head(data_with_subgroup)
```

For completeness, here is a full description of the columns in the data. Columns not related to time points or visits:

1. `subgroup`: User-supplied character vector indicating the subgroup of each patient.
2. `response`: User-supplied numeric vector of responses to the clinical endpoint. Could be `AVAL`.
3. `patient`: User-supplied character vector, ID of the patient in the study. Usually `USUBJID`.
4. `arm`: User-supplied character vector, study arm of the given patient.
5. `categorical1`, `categorical2`: User-supplied example categorical baseline covariates.
6. `continuous1`, `continuous2`: User-supplied example continuous baseline covariates.

Columns related to time points and visits:

1. `time_observed_continuous`: User-supplied numeric vector of continuous times corresponding to each observed patient visit. Varies from patient to patient. Units could be in years, months, or days, or some other unit. Must be on the same time scale as `time_scheduled_continuous`. (If the former is in weeks, then the latter must also be in weeks.)
2. `time_observed_index`: User-supplied integer index vector of *bins* of observed time points. These numeric labels should indicate groupings of time points based on rounding `time_observed_continuous` to a small set of strategic fixed time points.
3. `time_observed_factor`: Derived ordered factor version of `time_observed_index` to structure the correlation matrix. Derived as `ordered(as.character(time_observed_index), levels = as.character(sort(unique(time_observed_index))))`.
4. `time_scheduled_index`: User-supplied integer index vector of scheduled visit numbers. Usually `AVISITN`.
5. `time_scheduled_label`: User-supplied character vector of human-readable scheduled visit labels. Usually `AVISIT`.
6. `time_scheduled_continuous`: User-supplied numeric vector of continuous times of when each visit was scheduled. It must be on the same time scale as `time_scheduled_continuous`, the values must have a one-to-one correspondence with the scheduled visits in `time_scheduled_label`, and the baseline must have a value of 0. If the time scale is weeks, then the study team can create this variable in advance using `time_scheduled_label` (e.g. `AVISIT`). For example, if `AVISIT` is `"Baseline"`, then `time_scheduled_continuous` must be 0. If `time_scheduled_label` is `"Visit Number 5 (Week 24)"`, then `time_scheduled_continuous` should be 24.


The NCS subgroup analysis is a call to a single function: `ncs_analysis_subgroup()`. This produces a table of summary statistics, including LS means and confidence intervals.

```{r, message = FALSE}
subgroup_results <-
  ncs_analysis_subgroup(
    data = data_with_subgroup,
    response = "response",
    subject = "patient",
    arm = "arm",
    control_group = "control",
    subgroup = "subgroup",
    subgroup_comparator = "subgroup1",
    time_observed_continuous = "time_observed_continuous",
    time_observed_index = "time_observed_index",
    time_scheduled_continuous = "time_scheduled_continuous",
    time_scheduled_label = "time_scheduled_label",
    covariates = ~ continuous1 + categorical2,
    cov_structs = c("us", "toeph", "ar1h", "csh", "cs"),
    df = 3
  )
```

We can plot the model against the data.

```{r plot_means_subgroup}
ncs_plot_means_subgroup(subgroup_results$within)
```

Between-subgroup table:

```{r}
subgroup_results$between
```

Within-subgroup table:

```{r}
subgroup_results$within
```

The between-subgroup and within-subgroup tables have one row per study arm per timepoint per subgroup and the following columns.

* `arm`: study arm, i.e. treatment group
* `time`: discrete visit time labels from the `time_scheduled_label` column in the data.
* `subgroup`: subgroup level
* `n`: number of non-missing observations.
* `est`: observed mean response in the data.
* `sd`: observed standard deviation of the response in the data.
* `se`: observed standard error of the response in the data (just `se / sqrt(n)`).
* `lower`: lower bound of an observed 95% confidence interval in the data.
* `upper`: upper bound of an observed 95% confidence interval in the data.
* `response_est`: LS mean of the response.
* `response_se`: standard error of the LS mean of the response.
* `response_df`: degrees of freedom of the LS mean of the response.
* `response_lower`: lower 95% confidence bound of the LS mean of the response.
* `response_upper`: upper 95% confidence bound of the LS mean of the response.
* `change_est`, `change_lower`, `change_upper`, `change_se`, `change_df`: like the analogous `response_*` columns, but for LS mean change from baseline.
* `change_test_statistic`: test statistic of a two-sided test that the LS mean change from baseline is not equal to 0, at a significance level of 5%.
* `change_p_value`: same as `change_test_statistic`, but the p-value instead of the test statistic.
* `diff_arm_est`, `diff_arm_se`, `diff_arm_df`, `diff_arm_lower`, `diff_arm_upper`, `diff_arm_test_statistic`, `diff_arm_p_value`: same as the analogous `change_*` columns, but for treatment differences.
* `diff_subgroup_est`, `diff_subgroup_se`, `diff_subgroup_df`, `diff_subgroup_lower`, `diff_subgroup_upper`, `diff_subgroup_test_statistic`, `diff_subgroup_p_value`: same as the analogous `*_arm_*` columns, but for the subgroup differences.
* `percent_slowing_est` LS mean of percent slowing (on the percentage scale).
* `percent_slowing_lower`, `percent_slowing_upper`: a conservative approximation to a confidence interval on percent slowing. Assumes uncorrelated changes from baseline.
* `correlation`: correlation structure of the analysis subgroup model.
* `optimizer`: optimizer of the analysis subgroup model.

Type-III ANOVA fixed effects:

```{r}
subgroup_results$type3
```

There is also a table for the subgroup interaction test:

```{r}
subgroup_results$interaction
```

The test itself is a likelihood ratio test between a full model with subgroup-treatment interaction and a reduced model without subgroup-treatment interaction. The table has a row for the full model, a row for the reduced model, and the following columns.

* `model`: the model, either full or reduced.
* `df`: degrees of freedom
* `aic`: Akaike Information Criterion
* `bic`: Bayesian Information Criterion
* `loglik`: log likelihood
* `test_statistic`: test statistic of the likelihood ratio test.
* `p_value`: p-value of the likelihood ratio test.
* `correlation`: correlation structures of the full and reduced models of the interaction test.
* `optimizer`: optimizers of the full and reduced models of the interaction test.
